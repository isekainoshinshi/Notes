# 栈(stack)

`栈`是一种限制插入和删除在同一位置的表, 也就是`顶(top)`.这种特性也被称为`LIFO(last in, first out)`.

## 栈的链表实现

基于链表的栈在实现过程中跟链表本身的实现几乎没什么差别,
在有`头(header)`的情况中, 头就代表着栈, `push, pop, top`这些操作都是对除了头的最前的单元进行的.
并且所有操作的`时间复杂度`都是常数.

这种实现方式的缺点是: 花费时间最多的地方是在push, pop时创建单元的内存管理过程,
对于这些方面的费时一种方法是通过第二个栈来缓解, 在pop时不free, 而是将空间交给这个栈来持有,
当push时优先从这个栈中取出空间.

## 栈的数组实现

基于数组的实现方式执行的非常快且实现非常简单, `时间复杂度`为常数, 并且是非常快的那类常数.
在部分机器上甚至一个机器指令就可以实现push和pop, 因为这种实现方式运行非常快,
而且错误检测本身也很重要, 所以最好进行错误检测, 如果对运行速度极端的敏感再去掉也无妨.

## 例子

- 平衡符号
- 后缀表达式(postfix expression)以及中缀(infix)到后缀(posfix)的转换
- 函数调用

### 例子1

在括号匹配性的检测过程中, 对文件进行读取, 
当遇到左括号时, 将该括号放入栈,
当遇到右括号时, 调用栈的pop指令,
若左右括号不匹配或当前栈为空时, 则报错.

### 例子2

- 后缀表达式

`1 * 2 + 3 * 4`

这个表达式在计算时, 首先计算1 * 2保存在寄存器A, 之后计算3 * 4保存到寄存器B, 最后计算A + B结果保存到A中.
那么这个表达式通过上述过程可以写成下面这种形式:

`1 2 * 3 4 * + `

这种形式被称为`后缀(postfix)`或`逆波兰(reverse Polish)`记法.

这种记法非常适合使用栈来实现, 从头到位读取, 读到数字就把数字push到栈中,
读到符号就弹出两个数字使用该符号进行计算, 将结果push回栈中, 如此往复就可以得到结果.
后续表达式的计算`时间复杂度`为$O(N)$, 因为栈操作都是常数时间, 那么消耗的时间就仅与栈的大小有关.

- 中缀到后缀转换

对一个中缀形式(也就是正常的书写情况下)的表达式, 按照以下规则进行读取和输出:

```
读取到操作数(此例为数字), 则直接输出;
读取到操作符(此例为数学符号), 且该操作符的优先级低于或等于栈顶操作符的优先级时,
弹出并输出栈顶操作符后该操作符入栈;
括号的优先级最高, 且左括号只能在读取到右括号时进行弹出, 但是这对括号并不输出,
比如当前栈中为*(++, 当读取到)时, 会将++进行输出, 并将(弹出, 此时栈中仅剩下*;
+-之间优先级相等, 且在所有算数符号中最低, */^之间相等, 且高于+-, ()优先级最高.
```

### 例子3

在函数调用时, 调用函数的变量&运行到的位置需要保存, 
而被调用的函数在运行完返回的位置应与运行到的位置相对应,
那么可以看出来这个问题与例1中括号平衡的问题非常相似. 系统所需要做的就是将调用程序当前的状态&位置保存
(这些被保存的信息被称为`活动记录(activation record)`或`栈帧(stack frame)`),
放到栈中, 将控制权移交给被调用的程序; 
当执行完时, 恢复栈顶的状态, 然后返回之前运行的位置继续运行.

与上面概念描述不同的是: 
在实际应用中, 当前运行的环境是栈顶所描述的.

栈在使用过程中是由内存中高地址向低地址生长, 并且不会检查`上溢(overflow)`.

在一些功能的实现中会使用到`尾递归(tail recursion)`, 
这种递归方式指递归在函数的末尾进行, 通常尾递归可以由循环来代替,
但是通常的策略仍是使用递归, 确保最低限度的使用栈空间.
因为通过循环来实现会有运行速度的提升, 但是这也仅仅是弥补了由递归转换到循环所带来的代码清晰度的损失.

