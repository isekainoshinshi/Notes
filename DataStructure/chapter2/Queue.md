# 队列(queue)

队列也是一种表, 不过插入操作在一头, 删除操作在另一头.
时间复杂度为$O(1)$.

## 队列模型(queue model)

队列的两个基本操作是`入队(enqueue)`和`出队(dequeue)`. 
`入队`会在`尾部(rear)`进行插入操作;
`出队`会在`头部(front)`进行删除操作, 并返回其值的大小.
抽象来说就是`先进先出, 后进后出`.

## 队列的数组实现

队列也像堆一样, 由于有很高频率的操作, 所以不需要设置的非常大也足够使用.
但是由于队列的出队是在头部进行的, 那么会出现头部追赶上尾部以及尾部到数组的末尾的情况,
这种情况下可以使用`循环数组(circular array)`来实现队列.

使用循环数组的实现需要注意`队尾`的指向, 一种方式是队尾指向最后一个元素, 
另一种方式是队尾指向最后元素的后一个空位置,
这两种方式在循环队列实现中的所需要面临的情况是不同的.

- 队尾指向最后一个元素

对于这种方式的实现, 入队是`rear + 1`之后再赋值. 
有两种不同的选择来实现满队和空队的判断, 一是队列结构体中包含有记录队列现有元素数量的变量,另一个是不包含.
对于前者来说, 实现相对简单;
对于后者来说, 可以通过对一些特殊情况进行判断, 以及队首队尾位置间接判断现有元素数量,
当`front - 1 = rear`时为空队; 当`front - 1 = rear + 1`时为满队, 
那么虽然为满队, 但是仍然只使用了`MaxSize - 1`个位置, 只有这样才可以通过头和尾的位置判断出队列是否满了.

- 队尾指向最后一个元素的后一个位置

对于这种方式的实现, 入队是先赋值再`rear + 1`,
同样有两种不同的选择来实现满队和空队的判断, 与上面讨论的相同,
同样是前者相对容易实现;
对于后者来说, 当`front = rear`时为空队, 当`front - 1 = rear`时为满队, 理由同上.

## 例子

几个简单的队列的应用:

- 当有多个任务到达一个行式打印机时, 打印机会按照任务到达的次序进行执行.

有很多的队列理论用以解决像一个用户在队列中等待时间的期望, 
一个队列会排多长等类似的问题, 
这类问题与两个方面有关, 其一是用户到达队列的频率, 
其二是一名用户被服务时需要花费多长时间能够完成服务.

对于这类问题, 当服务人员很少时可以通过概率的角度去分析出答案,
但是当服务人员变得很大时, 就只能通过仿真的方式去得出答案, 那么这也是队列的一种应用.
