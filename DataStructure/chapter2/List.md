# 表(list)

除了空表, $A_{i + 1}$被称为`跟随(follow)`或`继承(success)`自$A_{i}$,
$A_{i - 1}$被称为`领先(predecess)`与$A_{i}$. 对于一个长度为$N$的表,
$A_{1}$的`前任(predecessor)`以及$A_{N}$的`继承者(successor)`是没有定义的.

## 以数组方式实现

以数组方式实现的话(无论是静态分配空间还是动态分配), 都需要对数组的大小进行大量的高估
(或预先知道所需数组的大小),这会造成大量的空间浪费;
并且在首位插入一个新元素会导致后续的所有元素都向后移位, 在最坏情况会导致$O(N)$的复杂度, 
对于删除操作同样会造成巨大的时间开销.

## 链表(linked list)

链表由特定结构体(structure)组成的结构, 结构体包括`元素(element)`以及
`指向下一个结构体的指针(Next pointer)`组成.

![](linked_list.png)

执行`PrintList, Find`操作时, 只需要按照`Next pointer`进行遍历即可,
但对于`FindKth`操作, 相比于使用数组实现的表所花费的时间更多, 会花费$O(i)$的时间;
但在实践中, 调用该函数通常会先依$i$进行排序再调用该函数, 所以实际遍历一次就可以完成.

`Delate, Insert`通过更改指针指向就可以实现.

在链表的实践过程中, 在删除时某一个节点时我们需要对被删除节点的前一个节点保持跟踪,
并且在删除首节点时是一个特殊情况, 通常可以设定一个`哨兵(sentinel)`节点, 
也被称为`表头(header), 哑节点(dummy node)`, 在链表中通常被定义为第0个节点.

递归的实现`Find`通常是为了避免粗心的结束条件, 但这种实现方式仍然是一个非常糟糕的实现方式.

之前提到的,除了`Find, FindPrevious`以外所有的操作都是$O(1)$的复杂度, 
那两个操作在最坏情况是$O(N)$的复杂度, 并且平均花费的时间也是$O(N)$, 
因为平均下来至少一半的元素会被访问.

### 双向链表(double linked list)

相比于前一节中的单向链表, 双向链表在结构中增加了一个指向前一项的指针,
这导致双向链表在`插入`和`删除`时花费双倍的时间, 但同时双向链表简化了删除操作.

### 循环链表(circularly linked list)

循环链表是将链表中最后一个项中指向下一项的指针赋值为链表中的第一项(有哑元则指向哑元),
也可以使用双向链表实现, 将链表中第一项的指向前一项的指针赋值为链表中的最后一项.
循环链表在某些应用场景中是比较流行的.

### 例子

1. 表示单变量多项式
2. 在某些情况下实现线性时间排序
3. 链表在跟踪学生课程注册问题中的应用

#### 例1

对于单变量多项式来说, 可以简单地使用下面的结构进行实现:

```C
typedef struct
{
int CoeffArray[` MaxDegree + 1 ];
int HighPower;
} * Polynomial;
```

这种方式对于稠密多项式(大部分次数项存在)的乘法来说是可以接受的,
但是对于其他的多项式会花费大量的时间去乘零系数.

使用链表的实现方式可以使用下面的结构:

```C
typedef struct Node* PtrToNode;
struct Node
{
int Coefficient;
int Exponent;
PtrToNode Next;
};
typedef PtrToNode Polynomiel;
```

#### 例2

例子2是链表在`基数排序`和`桶排序`上的应用. 

- 桶排序: 
假设存在一组数字, 一组中有`N`个数字, 并且知道这组数字的范围为0到M,
那么创建一个长度为M的数组`Count`, 并初始化为0, 对这组中每个数字$A_i$进行遍历, 每次对`Count[A_i]`加1.
这样遍历一次后按顺序显示即为排序完成的结果, `时间复杂度`为$O(M + N)$(M是初始化`Count`时花费的时间, 
N是遍历这组数字花费的时间), `空间复杂度`为$\Theta(M)$.

- 基数排序: 
基数排序是桶排序的一个推广, 假设一组$N$个数字的范围可以表示为0到$k^p - 1$,
那么`空间复杂度`为$O(k + N)$(可以理解为N是由数组使用的空间, k为桶的数量, 每次将数字放到桶中,
之后按照从前到后的顺序再将桶中的数据覆盖回数组), 
`时间复杂度`为$O(p(k + N))$(可以理解为进行P次桶排序,每次需要访问桶大小N加上上一次排序后的结果).

#### 例3

例子3是`多重表(multilists)`, 我们希望可以列出一个学生注册的所有课程以及一个课程中的所有学生,
对于有非常多课程以及学生时, 如果每个学生和课程都有列表去对应彼此, 那么会花费大量的空间,
为了节省空间可以采用`多重表`来实现这个需求,结构如下:

![](multilist.png)

其中每个节点中包含指向下一个学生注册该课程所产生节点的遍历课程用的指针, 
以及下一个课程包含学生所产生的节点的遍历学生用的指针.

但是这种结构有一个假定, 就是每个课程注册的学生相对较少且学生注册的课程相对较少,
每次通过课程查学生时, 需要横向遍历直到遇到课程链表的头, 
并在每个节点纵向遍历直到遇到学生链表的头(header)才能知道课程包含的学生的姓名,
为了解决这个问题可以通过在每个节点中添加一个指向学生头和课程头的指针,
这样以空间换取时间.

### 链表的游标实现

游标实现指的是在无法使用指针的时候, 通过数组的方式代替实现链表的功能,
并且还需要有链表的一些特点:

- 每个单元中有`元素`以及指向下一个单元的`指针`
- 可以通过`malloc`和`free`方便的创建和删除一个单元

第一个特点可以通过数组的索引来代替指针, 用结构体来代替单元.

第二个特点可以通过一个表来实现内存的分配, 这个`表(freelist)`需要知道数组中空着的位置,
这样通过与这个表的交互就可以达到类似于上面两个函数对内存控制的效果.

一种freelist实现方式有这样的一个特点, 被分配出去的空间是最近被回收回来的空间,
这种特性的数据结构被称为`栈(stack)`.

## 栈(stack)

`栈`是一种限制插入和删除在同一位置的表, 也就是`顶(top)`.这种特性也被称为`LIFO(last in, first out)`.

### 栈的链表实现

基于链表的栈在实现过程中跟链表本身的实现几乎没什么差别,
在有`头(header)`的情况中, 头就代表着栈, `push, pop, top`这些操作都是对除了头的最前的单元进行的.
并且所有操作的`时间复杂度`都是常数.

这种实现方式的缺点是: 花费时间最多的地方是在push, pop时创建单元的内存管理过程,
对于这些方面的费时一种方法是通过第二个栈来缓解, 在pop时不free, 而是将空间交给这个栈来持有,
当push时优先从这个栈中取出空间.

### 栈的数组实现

基于数组的实现方式执行的非常快且实现非常简单, `时间复杂度`为常数, 并且是非常快的那类常数.
在部分机器上甚至一个机器指令就可以实现push和pop, 因为这种实现方式运行非常快,
而且错误检测本身也很重要, 所以最好进行错误检测, 如果对运行速度极端的敏感再去掉也无妨.

### 例子

- 平衡符号
- 后缀表达式(postfix expression)以及中缀(infix)到后缀(posfix)的转换
- 函数调用

#### 例子1

在括号匹配性的检测过程中, 对文件进行读取, 
当遇到左括号时, 将该括号放入栈,
当遇到右括号时, 调用栈的pop指令,
若左右括号不匹配或当前栈为空时, 则报错.

#### 例子2

- 后缀表达式

`1 * 2 + 3 * 4`

这个表达式在计算时, 首先计算1 * 2保存在寄存器A, 之后计算3 * 4保存到寄存器B, 最后计算A + B结果保存到A中.
那么这个表达式通过上述过程可以写成下面这种形式:

`1 2 * 3 4 * + `

这种形式被称为`后缀(postfix)`或`逆波兰(reverse Polish)`记法.

这种记法非常适合使用栈来实现, 从头到位读取, 读到数字就把数字push到栈中,
读到符号就弹出两个数字使用该符号进行计算, 将结果push回栈中, 如此往复就可以得到结果.
后续表达式的计算`时间复杂度`为$O(N)$, 因为栈操作都是常数时间, 那么消耗的时间就仅与栈的大小有关.

- 中缀到后缀转换

对一个中缀形式(也就是正常的书写情况下)的表达式, 按照以下规则进行读取和输出:

```
读取到操作数(此例为数字), 则直接输出;
读取到操作符(此例为数学符号), 且该操作符的优先级低于或等于栈顶操作符的优先级时,
弹出并输出栈顶操作符后该操作符入栈;
括号的优先级最高, 且左括号只能在读取到右括号时进行弹出, 但是这对括号并不输出,
比如当前栈中为*(++, 当读取到)时, 会将++进行输出, 并将(弹出, 此时栈中仅剩下*;
+-之间优先级相等, 且在所有算数符号中最低, */^之间相等, 且高于+-, ()优先级最高.
```

#### 例子3

在函数调用时, 调用函数的变量&运行到的位置需要保存, 
而被调用的函数在运行完返回的位置应与运行到的位置相对应,
那么可以看出来这个问题与例1中括号平衡的问题非常相似. 系统所需要做的就是将调用程序当前的状态&位置保存
(这些被保存的信息被称为`活动记录(activation record)`或`栈帧(stack frame)`),
放到栈中, 将控制权移交给被调用的程序; 
当执行完时, 恢复栈顶的状态, 然后返回之前运行的位置继续运行.

与上面概念描述不同的是: 
在实际应用中, 当前运行的环境是栈顶所描述的.

栈在使用过程中是由内存中高地址向低地址生长, 并且不会检查`上溢(overflow)`.

在一些功能的实现中会使用到`尾递归(tail recursion)`, 
这种递归方式指递归在函数的末尾进行, 通常尾递归可以由循环来代替,
但是通常的策略仍是使用递归, 确保最低限度的使用栈空间.
因为通过循环来实现会有运行速度的提升, 但是这也仅仅是弥补了由递归转换到循环所带来的代码清晰度的损失.

## 队列(queue)
