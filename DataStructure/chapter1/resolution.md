# 课后题回答

## 2.1

$ 37 < \frac{2}{N} < N\log\log{N} < N\log{N} < N\log{N^{2}} < N\log^{2}{N} < \sqrt{N} < N < N^{1.5}
< N^{2} < N^{2}\log{N} < N^{3} < 2^{\frac{N}{2}} = 2^{N} $

## 2.2

a正确。根据原理可以知道$T_1(N) + T_2(N) = max(O(f(N)), O(f(N))) = O(f(N))$；
b错误。如果$T_2(N) << T_1(N)$那么不成立。
c错误。同上；
d错误。同上。

## 2.3

$N^{1+\frac{\epsilon}{\sqrt{\log{N}}}}$更大，因为指数要比log增长更快。

## 2.4

$$ \lim_{N \rightarrow +\infty} {\frac{\log^{k}{N}} {N}} $$
洛必达可得：
$$ \lim_{N \rightarrow +\infty} {k \frac{1} {\log{N}}} = 0$$
证毕

## 2.5

分段函数，如$f(N) = 1 when N \in odd$,$g(N) = 1 when N \in even$其余为0；

## 2.6

所有答案和解释都是$O$，不是准确值。

(1)$N$
(2)$N^{2}$
(3)$N^{3}$
(4)$N^{2}$
(5)$N^{5}$，并不需要算出准确的值，只需要按最坏运行时间去估计即可。
(6)$N^{4}$，总共会进行$N^{3}$次判断，因为对于第二个循环来说，他的变化范围为$1-i^2$，
这就意味着只有当变化到$1i, 2i, 3i...ii$，即总共$i$次，时才会进入最内部的循环，
那么进入到内部循环的次数为$N^{2}$，最内部循环跟$j$相关，最高为$N^{2}$，故$N^{4}$次

## 2.7

RandomNIntegersPermutation/implement.c

## 2.8

略

## 2.9

a. 由于$X^{i}$以简单相乘的方式会进行$i-1$次相乘, 再加上$A_{i}$，那么一共会进行$i$次相乘,
 那么根据式子$\sum_{i = 0}^{N}{A_{i} X^{i}}$,总共进行$0 + 1 + 2 + 3 + ... + N$即$O(N^{2})$.

b. 由于$X^{i}$以2.4.4的方法会执行$\log{i}$次, 那么总的可以认为最坏情况每次都是$\log{N}$,
 即$N\log{N}$.

## 2.10

a. 略

b. (( $(A_{N} ) X + A_{N - 1}) X + A_{N - 2})...) X + A_{0}$

c. $O(N)$

## 2.11

2_11/2_11.C

最坏情况下为$O(N)$.

## 2.12

2_12/2_12.c

## 2.13

2_13/2_13.c

## 2.14

预测为$O(N)$

## 2.15

首先计算$X^{64}$, 在这一步会进行6次乘法, 之后再进行两次乘法, 乘$\frac{ 1 }{ 2 }$, 总共8次乘法.

## 2.16

2_16/2_16.c

## 2.17

$$ n = \lfloor \log{ N } \rfloor + b( N ) - 1 $$

其中$\lfloor \rfloor$代表向下取整, $b( N )$代表$N$的二进制位数.

## 2.18

a. $150 N \log { N }$.

b. $N^{ 2 }$

c. (实际上答案并不确定, 因为我们目前已知的信息只有最坏情况, 后为我原始的回答.)
$150 N \log { N }$, 考虑到求和后再除以$N$, 该函数的平均值应该会小于$N^{ 2 }$.

d. 不考虑其他环境的限制, 如前者数据处理速度是这样, 但需要频繁的等待硬盘读写,而后者不需要,
后者应该总是会比前者花费的时间更多, 所以存在后者任意输入都比前者执行快的情况.

## 2.19

a. 首先,我没有想明白为什么要以递归的方式检查是否有相邻的同一个元素的,
但是,可以肯定的是,一定会在对比的元素的个数小于或等于2个的时候停止递归.

b. ~~可以通过检查是否存在数组的两头存在相同的元素, 
或者将数组看作是一个循环数组, 将开头和最后一个进行连续性的检验.~~
假如这个数组是个奇数, 根据主要元素的定义, 大于数组的一半即为主要元素,
奇数情况和奇数-1的情况对于主要元素数量的要求是相同的, 如数组长度8和9对主要元素都要求大于等于5个.
那么对$N - 1$个元素进行判断, 如果存在主要元素, 那么第$N$个元素对于前$N - 1$个元素中的主要元素是没有影响的;
但是如果前$N - 1$个元素中没有出现主要元素, 那么第$N$个元素则有可能是主要元素.

c. 考虑到这个算法会遍历一次A数组中的所有元素, 再加上一次B数组的所有元素,
所以这个算法的运行时间应为$O( N )$.

d. 可以通过在原始数组中通过某些方式标记连续相同元素的出现, 或者可以从头到尾遍历, 
在数组的结尾额外添加连续出现的元素和候选元素, 相当于是将B挪到了A后面.
(答案中说可以创建一个A的副本, 之后筛选完A的候选元素放到A的副本中, 之后在A的副本中重复)

## 2.20

~~因为不同操作系统中的整数在内存中占据的大小并不一定相同,
假设固定长度可以方便估算空间上的复杂度.~~
如果不假设整数是固定长度, 我们可以通过一些编码方式一次性并行的处理多个操作,
比如`A = 0x001, B = 0x101, C = 0x111, D = 0x100`, `A + C, B + D`就可以通过编码为
`0x00A00B + 0x00C00D`来并行的计算出前式.


## 2.21

(正确性不知)

a. $O( W \max \{ R^{ 2 }, C^{ 2 } \} )$

b. 可将$W$减少为$\log { W }$.

## 2.22

不可以, 因为在某些情况下程序会无法到达基准形况,
如`left = 0, right = 1`, 如果按照题中的方式修改, 那么会进入死循环

## 2.23

没想到

## 2.24

不可以

## 2.25

怀疑题目描述有误
